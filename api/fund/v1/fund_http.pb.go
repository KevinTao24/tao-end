// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.0
// - protoc             v3.19.4
// source: api/fund/v1/fund.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationFundCreateFund = "/api.fund.v1.Fund/CreateFund"
const OperationFundDeleteFund = "/api.fund.v1.Fund/DeleteFund"
const OperationFundGetFund = "/api.fund.v1.Fund/GetFund"
const OperationFundListFund = "/api.fund.v1.Fund/ListFund"
const OperationFundUpdateFund = "/api.fund.v1.Fund/UpdateFund"

type FundHTTPServer interface {
	CreateFund(context.Context, *CreateFundRequest) (*CreateFundReply, error)
	DeleteFund(context.Context, *DeleteFundRequest) (*DeleteFundReply, error)
	GetFund(context.Context, *GetFundRequest) (*GetFundReply, error)
	ListFund(context.Context, *ListFundRequest) (*ListFundReply, error)
	UpdateFund(context.Context, *UpdateFundRequest) (*UpdateFundReply, error)
}

func RegisterFundHTTPServer(s *http.Server, srv FundHTTPServer) {
	r := s.Route("/")
	r.POST("/api.fund.v1.Fund/CreateFund", _Fund_CreateFund0_HTTP_Handler(srv))
	r.POST("/api.fund.v1.Fund/UpdateFund", _Fund_UpdateFund0_HTTP_Handler(srv))
	r.POST("/api.fund.v1.Fund/DeleteFund", _Fund_DeleteFund0_HTTP_Handler(srv))
	r.POST("/api.fund.v1.Fund/GetFund", _Fund_GetFund0_HTTP_Handler(srv))
	r.POST("/api.fund.v1.Fund/ListFund", _Fund_ListFund0_HTTP_Handler(srv))
}

func _Fund_CreateFund0_HTTP_Handler(srv FundHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateFundRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFundCreateFund)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateFund(ctx, req.(*CreateFundRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateFundReply)
		return ctx.Result(200, reply)
	}
}

func _Fund_UpdateFund0_HTTP_Handler(srv FundHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateFundRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFundUpdateFund)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateFund(ctx, req.(*UpdateFundRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateFundReply)
		return ctx.Result(200, reply)
	}
}

func _Fund_DeleteFund0_HTTP_Handler(srv FundHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteFundRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFundDeleteFund)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteFund(ctx, req.(*DeleteFundRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteFundReply)
		return ctx.Result(200, reply)
	}
}

func _Fund_GetFund0_HTTP_Handler(srv FundHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFundRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFundGetFund)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFund(ctx, req.(*GetFundRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetFundReply)
		return ctx.Result(200, reply)
	}
}

func _Fund_ListFund0_HTTP_Handler(srv FundHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListFundRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFundListFund)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListFund(ctx, req.(*ListFundRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListFundReply)
		return ctx.Result(200, reply)
	}
}

type FundHTTPClient interface {
	CreateFund(ctx context.Context, req *CreateFundRequest, opts ...http.CallOption) (rsp *CreateFundReply, err error)
	DeleteFund(ctx context.Context, req *DeleteFundRequest, opts ...http.CallOption) (rsp *DeleteFundReply, err error)
	GetFund(ctx context.Context, req *GetFundRequest, opts ...http.CallOption) (rsp *GetFundReply, err error)
	ListFund(ctx context.Context, req *ListFundRequest, opts ...http.CallOption) (rsp *ListFundReply, err error)
	UpdateFund(ctx context.Context, req *UpdateFundRequest, opts ...http.CallOption) (rsp *UpdateFundReply, err error)
}

type FundHTTPClientImpl struct {
	cc *http.Client
}

func NewFundHTTPClient(client *http.Client) FundHTTPClient {
	return &FundHTTPClientImpl{client}
}

func (c *FundHTTPClientImpl) CreateFund(ctx context.Context, in *CreateFundRequest, opts ...http.CallOption) (*CreateFundReply, error) {
	var out CreateFundReply
	pattern := "/api.fund.v1.Fund/CreateFund"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFundCreateFund))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *FundHTTPClientImpl) DeleteFund(ctx context.Context, in *DeleteFundRequest, opts ...http.CallOption) (*DeleteFundReply, error) {
	var out DeleteFundReply
	pattern := "/api.fund.v1.Fund/DeleteFund"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFundDeleteFund))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *FundHTTPClientImpl) GetFund(ctx context.Context, in *GetFundRequest, opts ...http.CallOption) (*GetFundReply, error) {
	var out GetFundReply
	pattern := "/api.fund.v1.Fund/GetFund"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFundGetFund))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *FundHTTPClientImpl) ListFund(ctx context.Context, in *ListFundRequest, opts ...http.CallOption) (*ListFundReply, error) {
	var out ListFundReply
	pattern := "/api.fund.v1.Fund/ListFund"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFundListFund))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *FundHTTPClientImpl) UpdateFund(ctx context.Context, in *UpdateFundRequest, opts ...http.CallOption) (*UpdateFundReply, error) {
	var out UpdateFundReply
	pattern := "/api.fund.v1.Fund/UpdateFund"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFundUpdateFund))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
