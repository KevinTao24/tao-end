// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.0
// - protoc             v3.19.4
// source: api/llm/v1/llm.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationLlmCreateLlm = "/api.llm.v1.Llm/CreateLlm"
const OperationLlmDeleteLlm = "/api.llm.v1.Llm/DeleteLlm"
const OperationLlmGetLlm = "/api.llm.v1.Llm/GetLlm"
const OperationLlmListLlm = "/api.llm.v1.Llm/ListLlm"
const OperationLlmUpdateLlm = "/api.llm.v1.Llm/UpdateLlm"

type LlmHTTPServer interface {
	CreateLlm(context.Context, *CreateLlmRequest) (*CreateLlmReply, error)
	DeleteLlm(context.Context, *DeleteLlmRequest) (*DeleteLlmReply, error)
	GetLlm(context.Context, *GetLlmRequest) (*GetLlmReply, error)
	ListLlm(context.Context, *ListLlmRequest) (*ListLlmReply, error)
	UpdateLlm(context.Context, *UpdateLlmRequest) (*UpdateLlmReply, error)
}

func RegisterLlmHTTPServer(s *http.Server, srv LlmHTTPServer) {
	r := s.Route("/")
	r.POST("/api.llm.v1.Llm/CreateLlm", _Llm_CreateLlm0_HTTP_Handler(srv))
	r.POST("/api.llm.v1.Llm/UpdateLlm", _Llm_UpdateLlm0_HTTP_Handler(srv))
	r.POST("/api.llm.v1.Llm/DeleteLlm", _Llm_DeleteLlm0_HTTP_Handler(srv))
	r.POST("/api.llm.v1.Llm/GetLlm", _Llm_GetLlm0_HTTP_Handler(srv))
	r.POST("/api.llm.v1.Llm/ListLlm", _Llm_ListLlm0_HTTP_Handler(srv))
}

func _Llm_CreateLlm0_HTTP_Handler(srv LlmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateLlmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLlmCreateLlm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateLlm(ctx, req.(*CreateLlmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateLlmReply)
		return ctx.Result(200, reply)
	}
}

func _Llm_UpdateLlm0_HTTP_Handler(srv LlmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateLlmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLlmUpdateLlm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateLlm(ctx, req.(*UpdateLlmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateLlmReply)
		return ctx.Result(200, reply)
	}
}

func _Llm_DeleteLlm0_HTTP_Handler(srv LlmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteLlmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLlmDeleteLlm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteLlm(ctx, req.(*DeleteLlmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteLlmReply)
		return ctx.Result(200, reply)
	}
}

func _Llm_GetLlm0_HTTP_Handler(srv LlmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetLlmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLlmGetLlm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetLlm(ctx, req.(*GetLlmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetLlmReply)
		return ctx.Result(200, reply)
	}
}

func _Llm_ListLlm0_HTTP_Handler(srv LlmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListLlmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLlmListLlm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListLlm(ctx, req.(*ListLlmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListLlmReply)
		return ctx.Result(200, reply)
	}
}

type LlmHTTPClient interface {
	CreateLlm(ctx context.Context, req *CreateLlmRequest, opts ...http.CallOption) (rsp *CreateLlmReply, err error)
	DeleteLlm(ctx context.Context, req *DeleteLlmRequest, opts ...http.CallOption) (rsp *DeleteLlmReply, err error)
	GetLlm(ctx context.Context, req *GetLlmRequest, opts ...http.CallOption) (rsp *GetLlmReply, err error)
	ListLlm(ctx context.Context, req *ListLlmRequest, opts ...http.CallOption) (rsp *ListLlmReply, err error)
	UpdateLlm(ctx context.Context, req *UpdateLlmRequest, opts ...http.CallOption) (rsp *UpdateLlmReply, err error)
}

type LlmHTTPClientImpl struct {
	cc *http.Client
}

func NewLlmHTTPClient(client *http.Client) LlmHTTPClient {
	return &LlmHTTPClientImpl{client}
}

func (c *LlmHTTPClientImpl) CreateLlm(ctx context.Context, in *CreateLlmRequest, opts ...http.CallOption) (*CreateLlmReply, error) {
	var out CreateLlmReply
	pattern := "/api.llm.v1.Llm/CreateLlm"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLlmCreateLlm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LlmHTTPClientImpl) DeleteLlm(ctx context.Context, in *DeleteLlmRequest, opts ...http.CallOption) (*DeleteLlmReply, error) {
	var out DeleteLlmReply
	pattern := "/api.llm.v1.Llm/DeleteLlm"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLlmDeleteLlm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LlmHTTPClientImpl) GetLlm(ctx context.Context, in *GetLlmRequest, opts ...http.CallOption) (*GetLlmReply, error) {
	var out GetLlmReply
	pattern := "/api.llm.v1.Llm/GetLlm"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLlmGetLlm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LlmHTTPClientImpl) ListLlm(ctx context.Context, in *ListLlmRequest, opts ...http.CallOption) (*ListLlmReply, error) {
	var out ListLlmReply
	pattern := "/api.llm.v1.Llm/ListLlm"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLlmListLlm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LlmHTTPClientImpl) UpdateLlm(ctx context.Context, in *UpdateLlmRequest, opts ...http.CallOption) (*UpdateLlmReply, error) {
	var out UpdateLlmReply
	pattern := "/api.llm.v1.Llm/UpdateLlm"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLlmUpdateLlm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
